- Rev7 Todo
    
    - Check layouts of voltage regulators (U7 / U8 / U9)
        - Compare to datasheet recommendations
    
    - Finalize battery connector
    
    - Replace LEDs with correct ones after we do our LED testing
        - Position LEDs properly with respect to hole in enclosure!
    
    - LED flashing circuit: choose suitable R/C values depending on our LED testing
    
    - Confirm size/position of lens o-ring keepout region
    
    - Layout: length-match SD nets
    
    - Layout: length-match IMG nets
    
    - Layout: Figure out which parts are breaking when exposed to sunlight. Can we move components to solve?
        - Streaming images breaks in direct sunlight
    
    - Layout: fix DRC errors
    
    
    √ Layout: battery voltage divider: move resistors R7 and R9 closer together
    
    √ Layout: move parts away from lens gasket keepout region
    
    √ Layout: Move parts (resistors, capacitors) further away front mount points on front of board
        - We want more safety margin near mount points
    
    √ Layout: consider moving U21 so we have more space for the o-ring to expand
    
    √ Layout: Update mounting hole size based on enclosure hole size
    
    √ Layout: Make placing board into enclosure easier
        - Enclosure's bottom board mount needed to be snipped to give enough clearance
          to allow USB-C connector to go into hole
        
        - Enclosure's right backplate mount needed to be snipped to give enough clearance
            - Cut notch in board for clearance around right backplate mount?
            - Move backplate mounting points so that a notch can be cut?
        
        √ We should be good now because our bottom board mount is no longer there
    
    X Make BAT_CHRG_LVL_EN -> BAT_CHRG_LVL_EN_ so that it's open-drain, since it's now driven by both MSP430 and STM32
        X Nevermind, we can't do that because we'd need a pullup to VDD_BAT on the VDD_BAT buffer,
          and that exceeds MSP430's max rating. We don't want to pullup to VDD_A_3V3 either because it's an
          intermediate voltage that may causes excess current consumption.
    
    √ Choose suitable small-signal PMOS that'll work for both SD and LED subcircuits
        - DMG2305UX seems good, can we find anything better/cheaper?
            - Haven't been able to find anything better than DMG2305UX
    
    √ Add mosfet to allow motion sensor to be disabled, in case we're just in timelapse mode
    
    √ Add placeholder for LED flashing circuit (red+green)
        - How do we switch between red and green?
        - LED blinking circuit considerations
            - Can we use a pmos instead of nmos? Can we use the same small signal pmos that we're planning to use elsewhere?
                - The turn-on speed matters doesn't it?
            - We should implement the blinking circuit in a way that is impossible to leave on and kill the led via overcurrent. IE only pulses can be generated
    
    √ Route BAT_CHRG_LVL to MSP430 too, so MSP430 can sample the battery voltage (to blink LED)
    
    √ Replace NTB0102GF (U16) with a part that's easier to solder by hand
        - Some options:
            √ TXB0102
                - Went with this because:
                    - it's 2 channels (only need 1 part)
                    - easily soldered (BGA)
                    - low Ioff current (±2µA across entire temp range)
                    - direct replacement for NTB0102GF
            NTB0101GW
            74LVC1T45W6-7
            TXB0101
            NLSX4401DFT2G
            SN74LVC1T45
    
    X If ICE40 is going to interface directly with SD at 2.8V, can ICE40 interface directly with MSP?
        X No, see "Consider removing MSP430<->ICE40 level shifter"
    
    √ Remove MSP430<->STM32 level shifter (U15) and connect MSP_TEST / MSP_RST_ directly to STM32
        √ Connect VDDSDMMC to VDD_B_3V3_STM
        √ Connect MSP_TEST / MSP_RST_ to VDDSDMMC-powered pins
        X Switch capacitor on MSP_RST_ to the recommended one
            X We don't use 1nF anywhere else in the design
    
    X Consider removing MSP430<->ICE40 level shifter (U16) and use open-drain comms
        X Using open-drain comms is going to use significantly more power than using a level shifter
            X For example, to be able to hit 16 MHz, our pullup resistor will need to be 2.5k,
              so during comms, we'll burn 3.3/2.5e3 = 1.3mA when driving a 0, which sucks.
        - We only need open-drain comms on the data line, clock will always be push-pull driven by MSP430
        - Considerations:
            - Can ICE40 IOs handle being driven at 3.3V?
            - What pullup resistor value should we use?
            - Power consumption?
    
    √ How do we handle SD initialization?
        - Options:
            - Option 1: Require LVS SD cards and init with 1.8V
                - If all the high-endurance cards support LVS, this seems like a good option because:
                    - Less complexity, fewer parts
                        - No need for 2 extra ICE40 IOs that control pullup voltage
                        - No need for pull-up voltage transistors
                - DDR50 may let us loosen timing constraints, since the frequency is half, and the output SB_IO is responsible for outputting
            - Option 2: Allow non-LVS cards and init with 2.8V
                √ Option 2A: use an open-drain solution to be able to output 2.8V.
                X Option 2B: raise 1.8V to a higher voltage
                    X That won't work because:
                        - SD.Vih_min_3V3 = 0.625*VDD = 1.75
                        - SD.Vih_max_1V8 = 2.0
                        - ICE40.Voh_min = VCCIO–0.4
                        - Because SD.Vih_max_1V8=2, ICE40.VCCIO can't be greater than 2V. Therefore if ICE40.VCCIO=2, ICE40.Voh_min = VCCIO–0.4 = 2-.4 = 1.6
                            - But SD.Vih_min_3V3=1.75 > ICE40.Voh_min=1.6. In other words, SD requires >=1.75V to register as a '1',
                              but ICE40 may only be able to output 1.6V.
    
    √ SD: implement changing pullup voltage
    
    √ SD: Try 22k pull-up resistors for open-drain comms, so that we can use 400 kHz
        - The issue with this is how it affects the high-speed (102MHz) comms:
            - sd_cmd/sd_dat: the lower the resistance, the more the pullup will affect the high-speed signal
            - sd_clk: the lower the resistance, the more the capacitance of the small-signal mosfet will be visible
    
    X STM32: connect STM32.VBAT to VDD_B_3V3_STM if it helps with routing
        - Doesn't seem to matter whether we connect VBAT to 1.8 or 3.3
        X Nevermind: "If no external battery is used in the application, it is recommended to connect the VBAT pin to VDD"
    
    √ VDD_BAT voltage divider: if we connect STM32.VDDA to VDD_B_3V3_STM, change the voltage divider ratio
        - ratio of .75 (100k / 300k) seems good: .75*4.2 == 3.15, close to 3.3
    
    √ STM32: connect VREF+ and VDDA to VDD_B_3V3_STM so we can reduce the VDD_BAT voltage divider fraction to get more dynamic range
    
    √ Layout: fix USB receptacle layout for A9/B4 pins -- we didn't label the polygon correctly, resulting in a 'fork'
    
    √ Layout: Fix C17 label (obscured by pads)
    
    √ Layout: Make Q2 label the same size as Q3
    
    √ Layout: Fix J4 label (obscured)
    
    √ Layout: Fix R1/J1 labels (they're swapped)
    
    √ Layout: Remove cream from TagConnect footprint
    
    √ Swap ICE_STM_SPI nets so that ICERAMWrite can use QSPI to program, while ICEFlashWrite bitbangs
        - This seems like a good idea because we'll do ICERAMWrite anytime we run MDCStudio, but ICEFlashWrite only
          when flashing (which should happen rarely). Makes sense to have ICERAMWrite faster than ICEFlashWrite right?
            - Currently ICERAMWrite takes .5s when optimized with -Os
    
    √ Stop using VDD_USB as a signal; use TPS2116DRLR's ST signal instead, pulled to VDD_USB via a 10k resistor
        - Necessary because U12 appears to backfeed voltage to its enable pin, causing VDD_USB=2.5V.
            - Therefore its enable pin needs to be strongly driven (at least strongly driven low, weakly pulled high appears to work fine...)
        - 2 instances of using VDD_USB as a signal: U3, U12
    
    
    √ Battery voltage divider: change resistor values to take advantage of full ADC dynamic range
        - Currently our voltage divider ratio = 1/4 so the dynamic range = (4.2/4)/1.8 = 58% of full ADC range.
        - Switch the resistors of the voltage divider:
            - Option 1: 200k / 300k
                    - Voltage divider ratio = 1/2.5
                    - Dynamic range = (4.2/2.5)/1.8 = 93% of full ADC range.
            - Option 2: 100k / 147k (147k = 100k + 47k in series)
                - Voltage divider ratio = 1/2.47
                - Dynamic range = (4.2/2.47)/1.8 = 94% of full ADC range
            - Conclusion: use Option 1 because it's simplest
                - Just change R9 to be 200k
    
    
    √ Drive U5 (VDD_BAT voltage buffer) from an STM GPIO instead constantly while connected to USB
        - Necessary because the ADC voltage divider breaks MCP73831T's battery detection logic because
          its impedance is too low (MCP73831T requires an impedance of >7MΩ).
          - So instead, we'll disable the voltage divider except when a battery is detected
        
        - Drive from STM PA11/C15 pin
            - Need to use this pin because it can output 3.3V (by virtue of being supplied by VDDUSB)
              to meet the 74LVC1G98 Vih (2.74V when powered by 4.5V)
